\section{The Wollok Language}
\label{sec:wollokLanguage}

% Free form, variable number of sections, technical details.
% But in general do not mix solution and discussions/possible variation let that for discussion

Wollok is a brand new language, built to specifically give support to our pedagogical approach. 
Wollok provides aextremely simple programming model, which allows the students to create programs that including objects, messages and polymorphism, but without the need for more abstract concepts such as classes, inheritance or type annotations.
Later in the course, Wollok allows for the incremental introduction of more abstract concepts,
providing a smooth transition into a full-fledged OO programming model.

The example in figure \ref{fig:helloWorld/wollok} shows an example first program in a Wollok-based OO introductory course.
Syntax has been reduced to a minimum and the basic constructs of the language match exactly the concepts we want to transmit, \eg \code{var} is used to define variables and \code{method} is used to define methods.

\begin{figure}[ht]
 \centering
 \begin{lstlisting}[language=Wollok]
	object accumulator {
		var total = 0
		
		method getCurrentTotal() { return total }
		method add(amount) { total += amount }
	}
 \end{lstlisting}
 
 \caption{\small Sample initial Wollok program.}
 \label{fig:helloWorld/wollok}
\end{figure}

\medskip 

We put special emphasis in avoiding input and output (I/O). 
Normally, writing to standard output as it is shown in Fig. \ref{fig:helloWorld} will be considered a problem in industrial software construction.
Therefore, teaching our students to try out their programs in this way is introducing a bad practice that will have to be \emph{unlearned} later.
On the other hand, we need some kind of user interaction to be able to see the behavior of our programs and proper handling of user interaction is way beyond the scope of an initial OO course.

The first tool we introduce to try out a program without requiring I/O is a \emph {read-eval-print-loop} (REPL). Running a program in the REPL brings all defined objects to live and allows the user to interact with them sending messages, as shown in Fig. {fig:repl}. 
The REPL handles all I/O and the student is only required to write the desired \emph{domain object}.

\begin{figure}[ht]
 \centering
 \includegraphics[scale=0.6]{images/accumulator-repl.png}
 \caption{\small Sample usage of the accumulator program in the REPL}
 \label{fig:repl}
\end{figure}


%This is also consistent with some modern industrial OO languages that allow to define both classes or standalone objects, such as Scala \cite{Oder04a}.

%To build this first program students are not required to know about typing, scoping or packaging.
%The only required construct is the \code{program} and the only command is a message send.
%Both the receiver and the parameters are built-in objects which will be handled in the same way as user-defined objects.
%The concepts required to understand this program are no more than program, object, message and argument passing.

Shortly after in the course, we introduce unit testing which slowly replace the REPL as the main form of interacting with objects. Figure \ref{fig:test} shows a sample test for the previous program. 

\begin{figure}[ht]
 \centering
 \begin{lstlisting}[language=Wollok]
 	import accumulator.*

	test "accumulator starts with 0" {
		accumulator.add(2)
		accumulator.add(5)
		accumulator.add(8)
		assert.equals(15, accumulator.getCurrentTotal())		
	}
   
	test "accumulator starts with 0" {
		assert.equals(0, accumulator.getCurrentTotal())
	}
 \end{lstlisting}
 
 \caption{\small Sample initial Wollok program.}
 \label{fig:helloWorld/wollok}
\end{figure}

Again here Wollok is fine-tuned for our pedagogical objectives.
For example, tests have to be written in a separate file, which introduces the student into some basic knowledge of modularization.
Also, the test runner guarantees that there is no interaction between tests: the messages sent to the accumulator in the first test will not affect the state of the accumulator in the second test\np{sería lindo tener una cita a alguna regla de unit testing que proponga esto}.

\bigskip 
% Effect
\np{Esto requeriría una mención en la intro, o en general una explicación más detallada.}
Another concept we propose to emphasize in the first programming courses is the control of side effects, 
\ie a programmer should be aware of the potential side effects of each portion of code.
The most basic feature in Wollok to control side effects is the ability to 
differentiate variables (defined using \code{var})
from constants (defined using \code{const}).
One step forward is to incorporate an \emph{effect system} \cite{nielson_type_1999}, \cf Sec. \ref{sec:furtherWork}.

\medskip
% Misceláneos
% Profundizar y pulir el highlighting the conceptos primarios y la estratificacion de conceptos
To sum up, there are several simple features which help structure the way a student sees his programming activity.
\emph{Collection literals} reduce boilerplate on object creation, 
since we think that the excess of bureaucracy to create an object helps to build up 
the belief that using objects or collections is far more complicated than using numbers or strings, which in turns leads to \emph{primitive obsession} \cite{fowler_refactoring:_1999}.
% Objetos no como un elemento de la IDE -Ozono: nueva referencia global, sino como un elemnto del lenguaje. Evita referencias globales.

Each Wollok file has to be defined as \emph{program}, \emph{library} or \emph{test}.
Only programs and tests can be run. Libraries can only be \emph{imported} from programs, tests or other libraries.
This concepts push students onto modularizing their programs into smaller units that can be reutilized.

Figure \ref{fig:polymorphism} shows some of the mentioned features.
The programs includes two objects which are treated polymorphically, collections and block closures.
Students should be able to build such a program after four lectures.
In the first lecture we introduce objects, messages, methods and references;
in the second one we focus on polymorphism;
and in the following two we work with blocks and collections.

\np{Acá falta hablar de la diferencia entre objeto y referencia}

\begin{figure}[ht]
 \centering
 \begin{lstlisting}[language=Wollok]
	program myProgram {
		val optimistic = object {
			method hiThere() {
				"Hi, what an amazing day !"
			}
		}

		val pessimistic = object {
			method hiThere() {
				"Don't talk to me, it's a terrible day!"
			}
		}
		
		val all = #[optimistic, pessimistic]
		
		console.println(all.map[p| p.hiThere()])
	}
 \end{lstlisting}
 
 \caption{\small Simple polymorphism example.}
 \label{fig:polymorphism}
\end{figure}
